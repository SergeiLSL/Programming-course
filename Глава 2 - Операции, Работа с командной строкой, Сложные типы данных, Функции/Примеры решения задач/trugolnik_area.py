figure = input("1-прямоугольник, 2-треугольник, 3-круг: ")

if figure == '1':
    a = float(input("Ширина: "))
    b = float(input("Высота: "))
    print("Площадь: %.2f" % (a * b))
elif figure == '2':
    a = float(input("Основание: "))
    h = float(input("Высота: "))
    print("Площадь: %.2f" % (0.5 * a * h))
elif figure == '3':
    r = float(input("Радиус: "))
    print("Площадь: %.2f" % (3.14 * r ** 2))
else:
    print("Ошибка ввода")
# Здесь нет никаких функций, и все прекрасно. Но напишем вариант с функциями:
# ======================================================


def rectangle():
    a = float(input("Ширина: "))
    b = float(input("Высота: "))
    print("Площадь: %.2f" % (a * b))


def triangle():
    a = float(input("Основание: "))
    h = float(input("Высота: "))
    print("Площадь: %.2f" % (0.5 * a * h))


def circle():
    r = float(input("Радиус: "))
    print("Площадь: %.2f" % (3.14 * r ** 2))


figure = input("1-прямоугольник, 2-треугольник, 3-круг: ")
if figure == '1':
    rectangle()
elif figure == '2':
    triangle()
elif figure == '3':
    circle()
else:
    print("Ошибка ввода")

# Он кажется сложнее, а каждая из трех функций вызывается всего один раз.
# Однако из общей логики программы как бы убраны и обособлены инструкции для
# нахождения площадей. Программа теперь состоит из отдельных "кирпичиков Лего".
# В основной ветке мы можем комбинировать их как угодно. Она играет роль
# управляющего механизма.
# Если нам когда-нибудь захочется вычислять площадь треугольника по формуле
# Герона, а не через высоту, то не придется искать код во всей программе
# (представьте, что она состоит из тысяч строк кода как реальные программы).
# Мы пойдем к месту определения функций и изменим тело одной из них.
# Если понадобиться использовать эти функции в какой-нибудь другой программе,
# то мы сможем импортировать их туда, сославшись на данный файл с кодом
# (как это делается в Python, будет рассмотрено позже).
